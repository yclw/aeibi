// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: comment.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addCommentLike = `-- name: AddCommentLike :one
WITH inserted AS (
  INSERT INTO comment_likes (comment_uid, user_uid)
  VALUES ($1, $2) ON CONFLICT DO NOTHING
  RETURNING 1
),
updated AS (
  UPDATE post_comments
  SET like_count = like_count + 1,
    updated_at = now()
  WHERE uid = $1
    AND EXISTS (SELECT 1 FROM inserted)
  RETURNING like_count
)
SELECT like_count
FROM updated
UNION ALL
SELECT like_count
FROM post_comments
WHERE uid = $1
  AND NOT EXISTS (SELECT 1 FROM updated)
LIMIT 1
`

type AddCommentLikeParams struct {
	CommentUid uuid.UUID
	UserUid    uuid.UUID
}

func (q *Queries) AddCommentLike(ctx context.Context, arg AddCommentLikeParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, addCommentLike, arg.CommentUid, arg.UserUid)
	var like_count int32
	err := row.Scan(&like_count)
	return like_count, err
}

const archiveCommentByUidAndAuthor = `-- name: ArchiveCommentByUidAndAuthor :execrows
UPDATE post_comments
SET status = 'ARCHIVED'::comment_status,
  updated_at = now()
WHERE uid = $1
  AND author_uid = $2
  AND status = 'NORMAL'::comment_status
`

type ArchiveCommentByUidAndAuthorParams struct {
	Uid       uuid.UUID
	AuthorUid uuid.UUID
}

func (q *Queries) ArchiveCommentByUidAndAuthor(ctx context.Context, arg ArchiveCommentByUidAndAuthorParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, archiveCommentByUidAndAuthor, arg.Uid, arg.AuthorUid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createComment = `-- name: CreateComment :one
INSERT INTO post_comments (
    uid,
    post_uid,
    author_uid,
    root_uid,
    parent_uid,
    reply_to_author_uid,
    content,
    images,
    ip
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
  )
RETURNING id,
  uid
`

type CreateCommentParams struct {
	Uid              uuid.UUID
	PostUid          uuid.UUID
	AuthorUid        uuid.UUID
	RootUid          uuid.UUID
	ParentUid        uuid.NullUUID
	ReplyToAuthorUid uuid.NullUUID
	Content          string
	Images           []string
	Ip               string
}

type CreateCommentRow struct {
	ID  int32
	Uid uuid.UUID
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (CreateCommentRow, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.Uid,
		arg.PostUid,
		arg.AuthorUid,
		arg.RootUid,
		arg.ParentUid,
		arg.ReplyToAuthorUid,
		arg.Content,
		pq.Array(arg.Images),
		arg.Ip,
	)
	var i CreateCommentRow
	err := row.Scan(&i.ID, &i.Uid)
	return i, err
}

const decrementCommentReplyCount = `-- name: DecrementCommentReplyCount :one
UPDATE post_comments
SET reply_count = GREATEST(reply_count - 1, 0),
  updated_at = now()
WHERE uid = $1
  AND status = 'NORMAL'::comment_status
RETURNING reply_count
`

func (q *Queries) DecrementCommentReplyCount(ctx context.Context, commentUid uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, decrementCommentReplyCount, commentUid)
	var reply_count int32
	err := row.Scan(&reply_count)
	return reply_count, err
}

const decrementPostCommentCount = `-- name: DecrementPostCommentCount :one
UPDATE posts
SET comment_count = GREATEST(comment_count - 1, 0),
  updated_at = now()
WHERE uid = $1
  AND status = 'NORMAL'::post_status
RETURNING comment_count
`

func (q *Queries) DecrementPostCommentCount(ctx context.Context, postUid uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, decrementPostCommentCount, postUid)
	var comment_count int32
	err := row.Scan(&comment_count)
	return comment_count, err
}

const getCommentMetaByUid = `-- name: GetCommentMetaByUid :one
SELECT post_uid,
  author_uid,
  root_uid
FROM post_comments
WHERE uid = $1
  AND status = 'NORMAL'::comment_status
LIMIT 1
`

type GetCommentMetaByUidRow struct {
	PostUid   uuid.UUID
	AuthorUid uuid.UUID
	RootUid   uuid.UUID
}

func (q *Queries) GetCommentMetaByUid(ctx context.Context, uid uuid.UUID) (GetCommentMetaByUidRow, error) {
	row := q.db.QueryRowContext(ctx, getCommentMetaByUid, uid)
	var i GetCommentMetaByUidRow
	err := row.Scan(&i.PostUid, &i.AuthorUid, &i.RootUid)
	return i, err
}

const incrementCommentReplyCount = `-- name: IncrementCommentReplyCount :one
UPDATE post_comments
SET reply_count = reply_count + 1,
  updated_at = now()
WHERE uid = $1
  AND status = 'NORMAL'::comment_status
RETURNING reply_count
`

func (q *Queries) IncrementCommentReplyCount(ctx context.Context, commentUid uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, incrementCommentReplyCount, commentUid)
	var reply_count int32
	err := row.Scan(&reply_count)
	return reply_count, err
}

const incrementPostCommentCount = `-- name: IncrementPostCommentCount :one
UPDATE posts
SET comment_count = comment_count + 1,
  latest_replied_on = now(),
  updated_at = now()
WHERE uid = $1
  AND status = 'NORMAL'::post_status
RETURNING comment_count
`

func (q *Queries) IncrementPostCommentCount(ctx context.Context, postUid uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, incrementPostCommentCount, postUid)
	var comment_count int32
	err := row.Scan(&comment_count)
	return comment_count, err
}

const listReplies = `-- name: ListReplies :many
SELECT c.uid,
  u.uid AS author_uid,
  u.nickname AS author_nickname,
  u.avatar_url AS author_avatar_url,
  c.post_uid,
  c.root_uid,
  c.parent_uid,
  c.reply_to_author_uid,
  c.content,
  c.images,
  c.reply_count,
  c.like_count,
  (cl.user_uid IS NOT NULL)::boolean AS liked,
  c.created_at,
  c.updated_at,
  COUNT(*) OVER ()::int AS total
FROM post_comments c
  JOIN users u ON u.uid = c.author_uid
  AND u.status = 'NORMAL'::user_status
  LEFT JOIN comment_likes cl ON cl.comment_uid = c.uid
  AND cl.user_uid = $1::uuid
WHERE c.status = 'NORMAL'::comment_status
  AND c.root_uid = $2
  AND c.root_uid <> c.uid
ORDER BY c.created_at ASC,
  c.uid ASC
LIMIT 10 OFFSET ($3::int - 1) * 10
`

type ListRepliesParams struct {
	Viewer  uuid.NullUUID
	RootUid uuid.UUID
	Page    int32
}

type ListRepliesRow struct {
	Uid              uuid.UUID
	AuthorUid        uuid.UUID
	AuthorNickname   string
	AuthorAvatarUrl  string
	PostUid          uuid.UUID
	RootUid          uuid.UUID
	ParentUid        uuid.NullUUID
	ReplyToAuthorUid uuid.NullUUID
	Content          string
	Images           []string
	ReplyCount       int32
	LikeCount        int32
	Liked            bool
	CreatedAt        time.Time
	UpdatedAt        time.Time
	Total            int32
}

func (q *Queries) ListReplies(ctx context.Context, arg ListRepliesParams) ([]ListRepliesRow, error) {
	rows, err := q.db.QueryContext(ctx, listReplies, arg.Viewer, arg.RootUid, arg.Page)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRepliesRow
	for rows.Next() {
		var i ListRepliesRow
		if err := rows.Scan(
			&i.Uid,
			&i.AuthorUid,
			&i.AuthorNickname,
			&i.AuthorAvatarUrl,
			&i.PostUid,
			&i.RootUid,
			&i.ParentUid,
			&i.ReplyToAuthorUid,
			&i.Content,
			pq.Array(&i.Images),
			&i.ReplyCount,
			&i.LikeCount,
			&i.Liked,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopComments = `-- name: ListTopComments :many
SELECT c.uid,
  u.uid AS author_uid,
  u.nickname AS author_nickname,
  u.avatar_url AS author_avatar_url,
  c.post_uid,
  c.root_uid,
  c.parent_uid,
  c.reply_to_author_uid,
  c.content,
  c.images,
  c.reply_count,
  c.like_count,
  (cl.user_uid IS NOT NULL)::boolean AS liked,
  c.created_at,
  c.updated_at
FROM post_comments c
  JOIN users u ON u.uid = c.author_uid
  AND u.status = 'NORMAL'::user_status
  LEFT JOIN comment_likes cl ON cl.comment_uid = c.uid
  AND cl.user_uid = $1::uuid
WHERE c.status = 'NORMAL'::comment_status
  AND c.post_uid = $2
  AND c.parent_uid IS NULL
  AND (
    (
      $3::timestamptz IS NULL
      AND $4::uuid IS NULL
    )
    OR (c.created_at, c.uid) < (
      $3::timestamptz,
      $4::uuid
    )
  )
ORDER BY c.created_at DESC,
  c.uid DESC
LIMIT 20
`

type ListTopCommentsParams struct {
	Viewer          uuid.NullUUID
	PostUid         uuid.UUID
	CursorCreatedAt sql.NullTime
	CursorID        uuid.NullUUID
}

type ListTopCommentsRow struct {
	Uid              uuid.UUID
	AuthorUid        uuid.UUID
	AuthorNickname   string
	AuthorAvatarUrl  string
	PostUid          uuid.UUID
	RootUid          uuid.UUID
	ParentUid        uuid.NullUUID
	ReplyToAuthorUid uuid.NullUUID
	Content          string
	Images           []string
	ReplyCount       int32
	LikeCount        int32
	Liked            bool
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) ListTopComments(ctx context.Context, arg ListTopCommentsParams) ([]ListTopCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTopComments,
		arg.Viewer,
		arg.PostUid,
		arg.CursorCreatedAt,
		arg.CursorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTopCommentsRow
	for rows.Next() {
		var i ListTopCommentsRow
		if err := rows.Scan(
			&i.Uid,
			&i.AuthorUid,
			&i.AuthorNickname,
			&i.AuthorAvatarUrl,
			&i.PostUid,
			&i.RootUid,
			&i.ParentUid,
			&i.ReplyToAuthorUid,
			&i.Content,
			pq.Array(&i.Images),
			&i.ReplyCount,
			&i.LikeCount,
			&i.Liked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCommentLike = `-- name: RemoveCommentLike :one
WITH deleted AS (
  DELETE FROM comment_likes
  WHERE comment_uid = $1
    AND user_uid = $2
  RETURNING 1
),
updated AS (
  UPDATE post_comments
  SET like_count = GREATEST(like_count - 1, 0),
    updated_at = now()
  WHERE uid = $1
    AND EXISTS (SELECT 1 FROM deleted)
  RETURNING like_count
)
SELECT like_count
FROM updated
UNION ALL
SELECT like_count
FROM post_comments
WHERE uid = $1
  AND NOT EXISTS (SELECT 1 FROM updated)
LIMIT 1
`

type RemoveCommentLikeParams struct {
	CommentUid uuid.UUID
	UserUid    uuid.UUID
}

func (q *Queries) RemoveCommentLike(ctx context.Context, arg RemoveCommentLikeParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, removeCommentLike, arg.CommentUid, arg.UserUid)
	var like_count int32
	err := row.Scan(&like_count)
	return like_count, err
}
