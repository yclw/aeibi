// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: post.sql

package db

import (
	"context"
	"database/sql"
)

const addPostTag = `-- name: AddPostTag :exec
INSERT INTO post_tags (
  post_id,
  tag_id
) VALUES (
  ?1,
  ?2
) ON CONFLICT DO NOTHING
`

type AddPostTagParams struct {
	PostID int64
	TagID  int64
}

func (q *Queries) AddPostTag(ctx context.Context, arg AddPostTagParams) error {
	_, err := q.db.ExecContext(ctx, addPostTag, arg.PostID, arg.TagID)
	return err
}

const archivePostByUidAndAuthor = `-- name: ArchivePostByUidAndAuthor :execrows
UPDATE posts
SET
  status = 'ARCHIVED',
  updated_at = unixepoch()
WHERE uid = ?1
  AND author = ?2
  AND status = 'NORMAL'
`

type ArchivePostByUidAndAuthorParams struct {
	Uid    string
	Author string
}

func (q *Queries) ArchivePostByUidAndAuthor(ctx context.Context, arg ArchivePostByUidAndAuthorParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, archivePostByUidAndAuthor, arg.Uid, arg.Author)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const countMyCollections = `-- name: CountMyCollections :one
SELECT COUNT(1)
FROM post_collections pc
JOIN posts p ON p.uid = pc.post_uid
WHERE pc.user_uid = ?1
  AND p.status = 'NORMAL'
  AND (p.visibility = 'PUBLIC' OR p.author = ?1)
  AND (
    LENGTH(CAST(?2 AS TEXT)) = 0
    OR p.author = ?2
  )
  AND (
    LENGTH(CAST(?3 AS TEXT)) = 0
    OR p.visibility = ?3
  )
  AND (
    LENGTH(CAST(?4 AS TEXT)) = 0
    OR p.text LIKE '%' || ?4 || '%'
  )
  AND (
    LENGTH(CAST(?5 AS TEXT)) = 0
    OR EXISTS (
      SELECT 1
      FROM post_tags pt
      JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
        AND t.name = ?5
    )
  )
`

type CountMyCollectionsParams struct {
	UserUid    string
	Author     string
	Visibility string
	Search     string
	Tag        string
}

func (q *Queries) CountMyCollections(ctx context.Context, arg CountMyCollectionsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMyCollections,
		arg.UserUid,
		arg.Author,
		arg.Visibility,
		arg.Search,
		arg.Tag,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMyPosts = `-- name: CountMyPosts :one
SELECT COUNT(1)
FROM posts p
WHERE p.status = 'NORMAL'
  AND p.author = ?1
  AND (
    LENGTH(CAST(?2 AS TEXT)) = 0
    OR p.visibility = ?2
  )
  AND (
    LENGTH(CAST(?3 AS TEXT)) = 0
    OR p.text LIKE '%' || ?3 || '%'
  )
  AND (
    LENGTH(CAST(?4 AS TEXT)) = 0
    OR EXISTS (
      SELECT 1
      FROM post_tags pt
      JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
        AND t.name = ?4
    )
  )
`

type CountMyPostsParams struct {
	Author     string
	Visibility string
	Search     string
	Tag        string
}

func (q *Queries) CountMyPosts(ctx context.Context, arg CountMyPostsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMyPosts,
		arg.Author,
		arg.Visibility,
		arg.Search,
		arg.Tag,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicPosts = `-- name: CountPublicPosts :one
SELECT COUNT(1)
FROM posts p
WHERE p.status = 'NORMAL'
  AND p.visibility = 'PUBLIC'
  AND (
    LENGTH(CAST(?1 AS TEXT)) = 0
    OR p.author = ?1
  )
  AND (
    LENGTH(CAST(?2 AS TEXT)) = 0
    OR p.visibility = ?2
  )
  AND (
    LENGTH(CAST(?3 AS TEXT)) = 0
    OR p.text LIKE '%' || ?3 || '%'
  )
  AND (
    LENGTH(CAST(?4 AS TEXT)) = 0
    OR EXISTS (
      SELECT 1
      FROM post_tags pt
      JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
        AND t.name = ?4
    )
  )
`

type CountPublicPostsParams struct {
	Author     string
	Visibility string
	Search     string
	Tag        string
}

func (q *Queries) CountPublicPosts(ctx context.Context, arg CountPublicPostsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublicPosts,
		arg.Author,
		arg.Visibility,
		arg.Search,
		arg.Tag,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
  uid,
  author,
  text,
  images,
  attachments,
  visibility,
  pinned,
  ip
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  ?7,
  ?8
) RETURNING
  id,
  uid,
  author,
  text,
  images,
  attachments,
  comment_count,
  collection_count,
  like_count,
  pinned,
  visibility,
  latest_replied_on,
  ip,
  status,
  created_at,
  updated_at
`

type CreatePostParams struct {
	Uid         string
	Author      string
	Text        string
	Images      string
	Attachments string
	Visibility  string
	Pinned      int64
	Ip          string
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.Uid,
		arg.Author,
		arg.Text,
		arg.Images,
		arg.Attachments,
		arg.Visibility,
		arg.Pinned,
		arg.Ip,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Author,
		&i.Text,
		&i.Images,
		&i.Attachments,
		&i.CommentCount,
		&i.CollectionCount,
		&i.LikeCount,
		&i.Pinned,
		&i.Visibility,
		&i.LatestRepliedOn,
		&i.Ip,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePostCollection = `-- name: DeletePostCollection :execrows
DELETE FROM post_collections
WHERE post_uid = ?1
  AND user_uid = ?2
`

type DeletePostCollectionParams struct {
	PostUid string
	UserUid string
}

func (q *Queries) DeletePostCollection(ctx context.Context, arg DeletePostCollectionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePostCollection, arg.PostUid, arg.UserUid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deletePostLike = `-- name: DeletePostLike :execrows
DELETE FROM post_likes
WHERE post_uid = ?1
  AND user_uid = ?2
`

type DeletePostLikeParams struct {
	PostUid string
	UserUid string
}

func (q *Queries) DeletePostLike(ctx context.Context, arg DeletePostLikeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePostLike, arg.PostUid, arg.UserUid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deletePostTags = `-- name: DeletePostTags :exec
DELETE FROM post_tags
WHERE post_id = ?1
`

func (q *Queries) DeletePostTags(ctx context.Context, postID int64) error {
	_, err := q.db.ExecContext(ctx, deletePostTags, postID)
	return err
}

const getPostByUid = `-- name: GetPostByUid :one
SELECT
  id,
  uid,
  author,
  text,
  images,
  attachments,
  comment_count,
  collection_count,
  like_count,
  pinned,
  visibility,
  latest_replied_on,
  ip,
  status,
  created_at,
  updated_at
FROM posts
WHERE uid = ?1
  AND status = 'NORMAL'
LIMIT 1
`

func (q *Queries) GetPostByUid(ctx context.Context, uid string) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByUid, uid)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Author,
		&i.Text,
		&i.Images,
		&i.Attachments,
		&i.CommentCount,
		&i.CollectionCount,
		&i.LikeCount,
		&i.Pinned,
		&i.Visibility,
		&i.LatestRepliedOn,
		&i.Ip,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostByUidAndAuthor = `-- name: GetPostByUidAndAuthor :one
SELECT
  id,
  uid,
  author,
  text,
  images,
  attachments,
  comment_count,
  collection_count,
  like_count,
  pinned,
  visibility,
  latest_replied_on,
  ip,
  status,
  created_at,
  updated_at
FROM posts
WHERE uid = ?1
  AND author = ?2
  AND status = 'NORMAL'
LIMIT 1
`

type GetPostByUidAndAuthorParams struct {
	Uid    string
	Author string
}

func (q *Queries) GetPostByUidAndAuthor(ctx context.Context, arg GetPostByUidAndAuthorParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByUidAndAuthor, arg.Uid, arg.Author)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Author,
		&i.Text,
		&i.Images,
		&i.Attachments,
		&i.CommentCount,
		&i.CollectionCount,
		&i.LikeCount,
		&i.Pinned,
		&i.Visibility,
		&i.LatestRepliedOn,
		&i.Ip,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublicPostByUid = `-- name: GetPublicPostByUid :one
SELECT
  id,
  uid,
  author,
  text,
  images,
  attachments,
  comment_count,
  collection_count,
  like_count,
  pinned,
  visibility,
  latest_replied_on,
  ip,
  status,
  created_at,
  updated_at
FROM posts
WHERE uid = ?1
  AND visibility = 'PUBLIC'
  AND status = 'NORMAL'
LIMIT 1
`

func (q *Queries) GetPublicPostByUid(ctx context.Context, uid string) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPublicPostByUid, uid)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Author,
		&i.Text,
		&i.Images,
		&i.Attachments,
		&i.CommentCount,
		&i.CollectionCount,
		&i.LikeCount,
		&i.Pinned,
		&i.Visibility,
		&i.LatestRepliedOn,
		&i.Ip,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertPostCollection = `-- name: InsertPostCollection :execrows
INSERT INTO post_collections (
  post_uid,
  user_uid
) VALUES (
  ?1,
  ?2
) ON CONFLICT DO NOTHING
`

type InsertPostCollectionParams struct {
	PostUid string
	UserUid string
}

func (q *Queries) InsertPostCollection(ctx context.Context, arg InsertPostCollectionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertPostCollection, arg.PostUid, arg.UserUid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const insertPostLike = `-- name: InsertPostLike :execrows
INSERT INTO post_likes (
  post_uid,
  user_uid
) VALUES (
  ?1,
  ?2
) ON CONFLICT DO NOTHING
`

type InsertPostLikeParams struct {
	PostUid string
	UserUid string
}

func (q *Queries) InsertPostLike(ctx context.Context, arg InsertPostLikeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertPostLike, arg.PostUid, arg.UserUid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const listMyCollections = `-- name: ListMyCollections :many
SELECT
  p.id,
  p.uid,
  p.author,
  p.text,
  p.images,
  p.attachments,
  p.comment_count,
  p.collection_count,
  p.like_count,
  p.pinned,
  p.visibility,
  p.latest_replied_on,
  p.ip,
  p.status,
  p.created_at,
  p.updated_at
FROM post_collections pc
JOIN posts p ON p.uid = pc.post_uid
WHERE pc.user_uid = ?1
  AND p.status = 'NORMAL'
  AND (p.visibility = 'PUBLIC' OR p.author = ?1)
  AND (
    LENGTH(CAST(?2 AS TEXT)) = 0
    OR p.author = ?2
  )
  AND (
    LENGTH(CAST(?3 AS TEXT)) = 0
    OR p.visibility = ?3
  )
  AND (
    LENGTH(CAST(?4 AS TEXT)) = 0
    OR p.text LIKE '%' || ?4 || '%'
  )
  AND (
    LENGTH(CAST(?5 AS TEXT)) = 0
    OR EXISTS (
      SELECT 1
      FROM post_tags pt
      JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
        AND t.name = ?5
    )
  )
ORDER BY pc.created_at DESC, p.id DESC
LIMIT ?7
OFFSET ?6
`

type ListMyCollectionsParams struct {
	UserUid    string
	Author     string
	Visibility string
	Search     string
	Tag        string
	Offset     int64
	Limit      int64
}

func (q *Queries) ListMyCollections(ctx context.Context, arg ListMyCollectionsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, listMyCollections,
		arg.UserUid,
		arg.Author,
		arg.Visibility,
		arg.Search,
		arg.Tag,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Author,
			&i.Text,
			&i.Images,
			&i.Attachments,
			&i.CommentCount,
			&i.CollectionCount,
			&i.LikeCount,
			&i.Pinned,
			&i.Visibility,
			&i.LatestRepliedOn,
			&i.Ip,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyPosts = `-- name: ListMyPosts :many
SELECT
  p.id,
  p.uid,
  p.author,
  p.text,
  p.images,
  p.attachments,
  p.comment_count,
  p.collection_count,
  p.like_count,
  p.pinned,
  p.visibility,
  p.latest_replied_on,
  p.ip,
  p.status,
  p.created_at,
  p.updated_at
FROM posts p
WHERE p.status = 'NORMAL'
  AND p.author = ?1
  AND (
    LENGTH(CAST(?2 AS TEXT)) = 0
    OR p.visibility = ?2
  )
  AND (
    LENGTH(CAST(?3 AS TEXT)) = 0
    OR p.text LIKE '%' || ?3 || '%'
  )
  AND (
    LENGTH(CAST(?4 AS TEXT)) = 0
    OR EXISTS (
      SELECT 1
      FROM post_tags pt
      JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
        AND t.name = ?4
    )
  )
ORDER BY p.created_at DESC, p.id DESC
LIMIT ?6
OFFSET ?5
`

type ListMyPostsParams struct {
	Author     string
	Visibility string
	Search     string
	Tag        string
	Offset     int64
	Limit      int64
}

func (q *Queries) ListMyPosts(ctx context.Context, arg ListMyPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, listMyPosts,
		arg.Author,
		arg.Visibility,
		arg.Search,
		arg.Tag,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Author,
			&i.Text,
			&i.Images,
			&i.Attachments,
			&i.CommentCount,
			&i.CollectionCount,
			&i.LikeCount,
			&i.Pinned,
			&i.Visibility,
			&i.LatestRepliedOn,
			&i.Ip,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostTagsByUid = `-- name: ListPostTagsByUid :many
SELECT t.name
FROM tags t
JOIN post_tags pt ON pt.tag_id = t.id
JOIN posts p ON p.id = pt.post_id
WHERE p.uid = ?1
ORDER BY t.id
`

func (q *Queries) ListPostTagsByUid(ctx context.Context, uid string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listPostTagsByUid, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicPosts = `-- name: ListPublicPosts :many
SELECT
  p.id,
  p.uid,
  p.author,
  p.text,
  p.images,
  p.attachments,
  p.comment_count,
  p.collection_count,
  p.like_count,
  p.pinned,
  p.visibility,
  p.latest_replied_on,
  p.ip,
  p.status,
  p.created_at,
  p.updated_at
FROM posts p
WHERE p.status = 'NORMAL'
  AND p.visibility = 'PUBLIC'
  AND (
    LENGTH(CAST(?1 AS TEXT)) = 0
    OR p.author = ?1
  )
  AND (
    LENGTH(CAST(?2 AS TEXT)) = 0
    OR p.visibility = ?2
  )
  AND (
    LENGTH(CAST(?3 AS TEXT)) = 0
    OR p.text LIKE '%' || ?3 || '%'
  )
  AND (
    LENGTH(CAST(?4 AS TEXT)) = 0
    OR EXISTS (
      SELECT 1
      FROM post_tags pt
      JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
        AND t.name = ?4
    )
  )
ORDER BY p.created_at DESC, p.id DESC
LIMIT ?6
OFFSET ?5
`

type ListPublicPostsParams struct {
	Author     string
	Visibility string
	Search     string
	Tag        string
	Offset     int64
	Limit      int64
}

func (q *Queries) ListPublicPosts(ctx context.Context, arg ListPublicPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, listPublicPosts,
		arg.Author,
		arg.Visibility,
		arg.Search,
		arg.Tag,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Author,
			&i.Text,
			&i.Images,
			&i.Attachments,
			&i.CommentCount,
			&i.CollectionCount,
			&i.LikeCount,
			&i.Pinned,
			&i.Visibility,
			&i.LatestRepliedOn,
			&i.Ip,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostByUidAndAuthor = `-- name: UpdatePostByUidAndAuthor :one
UPDATE posts
SET
  text = COALESCE(?1, text),
  images = COALESCE(?2, images),
  attachments = COALESCE(?3, attachments),
  visibility = COALESCE(?4, visibility),
  pinned = CASE
    WHEN ?5 IS NULL THEN pinned
    ELSE CASE WHEN CAST(?5 AS INTEGER) = 1 THEN 1 ELSE 0 END
  END,
  updated_at = unixepoch()
WHERE uid = ?6
  AND author = ?7
  AND status = 'NORMAL'
RETURNING
  id,
  uid,
  author,
  text,
  images,
  attachments,
  comment_count,
  collection_count,
  like_count,
  pinned,
  visibility,
  latest_replied_on,
  ip,
  status,
  created_at,
  updated_at
`

type UpdatePostByUidAndAuthorParams struct {
	Text        sql.NullString
	Images      sql.NullString
	Attachments sql.NullString
	Visibility  sql.NullString
	Pinned      interface{}
	Uid         string
	Author      string
}

func (q *Queries) UpdatePostByUidAndAuthor(ctx context.Context, arg UpdatePostByUidAndAuthorParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePostByUidAndAuthor,
		arg.Text,
		arg.Images,
		arg.Attachments,
		arg.Visibility,
		arg.Pinned,
		arg.Uid,
		arg.Author,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Author,
		&i.Text,
		&i.Images,
		&i.Attachments,
		&i.CommentCount,
		&i.CollectionCount,
		&i.LikeCount,
		&i.Pinned,
		&i.Visibility,
		&i.LatestRepliedOn,
		&i.Ip,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePostCollectionCount = `-- name: UpdatePostCollectionCount :execrows
UPDATE posts
SET
  collection_count = CASE
    WHEN collection_count + ?1 < 0 THEN 0
    ELSE collection_count + ?1
  END,
  updated_at = unixepoch()
WHERE uid = ?2
  AND status = 'NORMAL'
`

type UpdatePostCollectionCountParams struct {
	Delta int64
	Uid   string
}

func (q *Queries) UpdatePostCollectionCount(ctx context.Context, arg UpdatePostCollectionCountParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updatePostCollectionCount, arg.Delta, arg.Uid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updatePostLikeCount = `-- name: UpdatePostLikeCount :execrows
UPDATE posts
SET
  like_count = CASE
    WHEN like_count + ?1 < 0 THEN 0
    ELSE like_count + ?1
  END,
  updated_at = unixepoch()
WHERE uid = ?2
  AND status = 'NORMAL'
`

type UpdatePostLikeCountParams struct {
	Delta int64
	Uid   string
}

func (q *Queries) UpdatePostLikeCount(ctx context.Context, arg UpdatePostLikeCountParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updatePostLikeCount, arg.Delta, arg.Uid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const upsertTag = `-- name: UpsertTag :one
INSERT INTO tags (name) VALUES (?1)
ON CONFLICT(name) DO UPDATE SET
  name = excluded.name
RETURNING id, name
`

func (q *Queries) UpsertTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, upsertTag, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}
